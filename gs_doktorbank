// CONFIGURA√á√ÉO DA PLANILHA FILHA DOKTORBANK (SOMENTE LEITURA) - CORRIGIDA PARA USAR ETAPAS
const CONFIG_FILHA = {
  ID_PLANILHA_MAE: "1V4iGN14UpIQcwf3qKU0_Wbiy2exdW2WUmrYTniy0upA",
  WAITLABEL_FILHA: "Doktorbank", // Waitlabel espec√≠fico do Doktorbank
  TIMEZONE: "America/Sao_Paulo"
};

// üî•üî•üî• FUN√á√ÉO CORRIGIDA - SIMPLIFICADA PARA VISUALIZA√á√ÉO
function formatarDataBrasilVisualizacao(data) {
  if (!data) return '';
  
  try {
    console.log("üìÖ formatarDataBrasilVisualizacao - Entrada:", data, "Tipo:", typeof data);
    
    // üî• CORRE√á√ÉO: Se j√° √© string no formato correto, retornar COMO EST√Å
    if (typeof data === 'string') {
      // Verificar se j√° est√° no formato dd/MM/yyyy HH:mm:ss
      if (data.match(/^\d{2}\/\d{2}\/\d{4} \d{2}:\d{2}:\d{2}$/)) {
        console.log("‚úÖ J√° est√° no formato correto - retornando como est√°:", data);
        return data;
      }
      // Verificar se est√° no formato dd/MM/yyyy
      if (data.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
        console.log("‚úÖ J√° est√° no formato data simples - retornando como est√°:", data);
        return data;
      }
    }
    
    // Se √© objeto Date, formatar CORRETAMENTE
    if (data instanceof Date) {
      const dataBrasil = Utilities.formatDate(data, CONFIG_FILHA.TIMEZONE, "dd/MM/yyyy HH:mm:ss");
      console.log("‚úÖ Date convertido:", data.toString(), "‚Üí", dataBrasil);
      return dataBrasil;
    }
    
    // Para outros casos, tentar converter
    try {
      const dataObj = new Date(data);
      if (!isNaN(dataObj.getTime())) {
        const dataBrasil = Utilities.formatDate(dataObj, CONFIG_FILHA.TIMEZONE, "dd/MM/yyyy HH:mm:ss");
        console.log("‚úÖ Outro tipo convertido:", data, "‚Üí", dataBrasil);
        return dataBrasil;
      }
    } catch (e) {
      console.log("‚ö†Ô∏è N√£o conseguiu converter, retornando original:", data);
      return data.toString();
    }
    
    return data ? data.toString() : '';
    
  } catch (error) {
    console.error("‚ùå Erro em formatarDataBrasilVisualizacao:", error);
    return data ? data.toString() : '';
  }
}

// üî•üî•üî• FUN√á√ÉO PRINCIPAL CORRIGIDA
function doGet() {
  const htmlOutput = HtmlService.createHtmlOutputFromFile('IndexFilha')
    .setTitle('Sistema Doktorbank - Visualiza√ß√£o de Dados')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  
  return htmlOutput;
}

// üî•üî•üî• BUSCAR TODOS OS CADASTROS - VERS√ÉO CORRIGIDA COM FUSO HOR√ÅRIO
function buscarTodosCadastrosComWaitlabel(waitlabel) {
  try {
    console.log("üîç [DOKTORBANK] Buscando dados no waitlabel:", waitlabel);
    
    const ss = SpreadsheetApp.openById(CONFIG_FILHA.ID_PLANILHA_MAE);
    const aba = ss.getSheetByName(waitlabel);
    
    if (!aba) {
      console.log("‚ùå Aba n√£o encontrada:", waitlabel);
      return [];
    }
    
    const ultimaLinha = aba.getLastRow();
    console.log("üìä √öltima linha encontrada:", ultimaLinha);
    
    if (ultimaLinha < 2) return [];
    
    // Buscar dados - usar n√∫mero fixo de colunas para consist√™ncia
    const dados = aba.getRange(2, 1, ultimaLinha - 1, 17).getValues();
    console.log("üìà Dados brutos encontrados:", dados.length);
    
    const cadastros = [];
    
    for (let i = 0; i < dados.length; i++) {
      const linha = dados[i];
      
      if (!linha || !linha[0] || linha[0].toString().trim() === '') continue;

      // üî•üî•üî• CORRE√á√ÉO CR√çTICA: Processamento CORRETO de datas COM FUSO HOR√ÅRIO
      let ultimaEtapaFormatada = linha[4] ? linha[4].toString() : '';
      
      // Se √© Date, formatar corretamente SUBTRAINDO 5 HORAS
      if (linha[4] instanceof Date) {
        // üî• CORRE√á√ÉO DO FUSO: Subtrair 5 horas para UTC ‚Üí Bras√≠lia
        const dataUTC = linha[4];
        const dataBrasilia = new Date(dataUTC.getTime() - (5 * 60 * 60 * 1000));
        ultimaEtapaFormatada = Utilities.formatDate(dataBrasilia, CONFIG_FILHA.TIMEZONE, "dd/MM/yyyy HH:mm:ss");
      }
      
      let ativacaoFormatada = linha[9] ? linha[9].toString() : '';
      
      // Se √© Date, formatar para exibi√ß√£o simples
      if (linha[9] instanceof Date) {
        ativacaoFormatada = Utilities.formatDate(linha[9], CONFIG_FILHA.TIMEZONE, "dd/MM/yyyy");
      }

      // üî• CORRE√á√ÉO: Processamento do percentual - MAIS SIMPLES
      let percentualTarifa = '0%';
      if (linha[14] !== null && linha[14] !== undefined && linha[14] !== '') {
        const valor = linha[14];
        
        if (typeof valor === 'number') {
          // N√∫mero direto: 0.035 ‚Üí 3.50%
          percentualTarifa = (valor * 100).toFixed(2) + '%';
        } else if (typeof valor === 'string') {
          const valorStr = valor.toString().trim();
          if (valorStr.includes('%')) {
            percentualTarifa = valorStr;
          } else {
            // Tentar converter string para n√∫mero
            const valorNum = parseFloat(valorStr.replace(',', '.'));
            if (!isNaN(valorNum)) {
              percentualTarifa = valorNum.toFixed(2) + '%';
            }
          }
        }
      }

      // üî• CORRE√á√ÉO: Processamento da ades√£o - MAIS SIMPLES
      let adesaoFormatada = 'Isento';
      if (linha[15] !== null && linha[15] !== undefined && linha[15] !== '') {
        const valorAdesao = linha[15];
        if (typeof valorAdesao === 'number' && valorAdesao > 0) {
          adesaoFormatada = valorAdesao;
        } else if (typeof valorAdesao === 'string') {
          const valorStr = valorAdesao.toString().trim();
          if (valorStr !== 'Isento' && valorStr !== '0' && valorStr !== '0.00') {
            const valorNum = parseFloat(valorStr.replace('R$', '').replace(/\./g, '').replace(',', '.').trim());
            if (!isNaN(valorNum) && valorNum > 0) {
              adesaoFormatada = valorNum;
            }
          }
        }
      }

      // üî•üî•üî• CORRE√á√ÉO: AGORA USA "ETAPA" EM VEZ DE "EVENTO"
      const cadastro = {
        id: i + 2,
        razao_social: linha[0]?.toString().trim() || '',
        nome_fantasia: linha[1]?.toString().trim() || '',
        cnpj: formatarCNPJNoSheets(linha[2]?.toString().trim() || ''),
        fornecedor: linha[3]?.toString().trim() || '',
        ultima_etapa: ultimaEtapaFormatada, // üî• MUDOU: ultima_etapa em vez de ultimo_evento
        etapa: linha[5]?.toString().trim() || '', // üî• MUDOU: etapa em vez de evento
        observacoes: linha[6]?.toString().trim() || '',
        contrato_enviado: linha[7]?.toString().trim() || '',
        contrato_assinado: linha[8]?.toString().trim() || '',
        ativacao: ativacaoFormatada,
        link: linha[10]?.toString().trim() || '',
        mensalidade: typeof linha[11] === 'number' ? linha[11] : 0,
        mensalidade_sim: typeof linha[12] === 'number' ? linha[12] : 0,
        tarifa: linha[13]?.toString().trim() || '',
        percentual_tarifa: percentualTarifa,
        adesao: adesaoFormatada,
        situacao: (linha[16]?.toString().trim() || 'Novo registro'),
        waitlabel: waitlabel
      };
      
      cadastros.push(cadastro);
    }
    
    console.log("‚úÖ [DOKTORBANK] Dados carregados para visualiza√ß√£o:", cadastros.length);
    return cadastros;
    
  } catch (error) {
    console.error("‚ùå [DOKTORBANK] Erro na busca:", error);
    return [];
  }
}

// üî•üî•üî• BUSCAR CADASTRO POR ID - VERS√ÉO CORRIGIDA COM FUSO HOR√ÅRIO
function buscarCadastroPorIDComWaitlabel(id, waitlabel) {
  try {
    console.log("üîç [DOKTORBANK] Buscando cadastro por ID:", id, "no waitlabel:", waitlabel);
    
    const ss = SpreadsheetApp.openById(CONFIG_FILHA.ID_PLANILHA_MAE);
    const aba = ss.getSheetByName(waitlabel);
    if (!aba) return { encontrado: false, mensagem: "Waitlabel n√£o encontrado" };
    
    const ultimaLinha = aba.getLastRow();
    if (ultimaLinha < id) return { encontrado: false, mensagem: "Registro n√£o encontrado" };
    
    const linha = aba.getRange(id, 1, 1, 17).getValues()[0];
    
    if (!linha[0] || linha[0].toString().trim() === '') {
      return { encontrado: false, mensagem: "Registro vazio ou n√£o encontrado" };
    }

    console.log("üìä [DOKTORBANK] DEBUG - Linha encontrada na linha", id);
    console.log("üîç Coluna E [4] - √öltima etapa:", linha[4], "Tipo:", typeof linha[4]);
    console.log("üîç Coluna J [9] - Ativa√ß√£o:", linha[9], "Tipo:", typeof linha[9]);

    // üî•üî•üî• CORRE√á√ÉO CR√çTICA: Processamento CORRETO das datas COM FUSO HOR√ÅRIO
    let ultimaEtapaFormatada = linha[4] ? linha[4].toString() : '';
    
    // Se √© Date, formatar SUBTRAINDO 5 HORAS para corre√ß√£o do fuso
    if (linha[4] instanceof Date) {
      // üî• CORRE√á√ÉO DO FUSO: Subtrair 5 horas para UTC ‚Üí Bras√≠lia
      const dataUTC = linha[4];
      const dataBrasilia = new Date(dataUTC.getTime() - (5 * 60 * 60 * 1000));
      ultimaEtapaFormatada = Utilities.formatDate(dataBrasilia, CONFIG_FILHA.TIMEZONE, "dd/MM/yyyy HH:mm:ss");
    }
    
    let ativacaoFormatada = '';
    if (linha[9]) {
      if (linha[9] instanceof Date) {
        // üî• CORRE√á√ÉO: Para input date, usar formato yyyy-MM-dd
        ativacaoFormatada = Utilities.formatDate(linha[9], CONFIG_FILHA.TIMEZONE, "yyyy-MM-dd");
      } else {
        // Se j√° √© string, verificar formato e converter se necess√°rio
        const dataStr = linha[9].toString();
        if (dataStr.includes('/')) {
          // Converter de dd/MM/yyyy para yyyy-MM-dd
          const partes = dataStr.split('/');
          if (partes.length === 3) {
            ativacaoFormatada = `${partes[2]}-${partes[1]}-${partes[0]}`;
          } else {
            ativacaoFormatada = dataStr;
          }
        } else {
          ativacaoFormatada = dataStr;
        }
      }
    }

    // üî• CORRE√á√ÉO: Processamento SIMPLIFICADO do percentual
    let percentualTarifa = '0%';
    if (linha[14] !== null && linha[14] !== undefined && linha[14] !== '') {
      const valor = linha[14];
      
      if (typeof valor === 'number') {
        percentualTarifa = (valor * 100).toFixed(2) + '%';
      } else if (typeof valor === 'string') {
        const valorStr = valor.toString().trim();
        if (valorStr.includes('%')) {
          percentualTarifa = valorStr;
        } else {
          const valorNum = parseFloat(valorStr.replace(',', '.'));
          if (!isNaN(valorNum)) {
            percentualTarifa = valorNum.toFixed(2) + '%';
          }
        }
      }
    }

    // üî• CORRE√á√ÉO: Processamento SIMPLIFICADO da ades√£o
    let adesaoFormatada = 'Isento';
    if (linha[15] !== null && linha[15] !== undefined && linha[15] !== '') {
      const valorAdesao = linha[15];
      if (typeof valorAdesao === 'number' && valorAdesao > 0) {
        adesaoFormatada = valorAdesao;
      } else if (typeof valorAdesao === 'string') {
        const valorStr = valorAdesao.toString().trim();
        if (valorStr !== 'Isento' && valorStr !== '0' && valorStr !== '0.00') {
          const valorNum = parseFloat(valorStr.replace('R$', '').replace(/\./g, '').replace(',', '.').trim());
          if (!isNaN(valorNum) && valorNum > 0) {
            adesaoFormatada = valorNum;
          }
        }
      }
    }

    // üî•üî•üî• CORRE√á√ÉO: AGORA USA "ETAPA" EM VEZ DE "EVENTO"
    const resultado = {
      encontrado: true,
      id: id,
      razao_social: linha[0]?.toString().trim() || '',
      nome_fantasia: linha[1]?.toString().trim() || '',
      cnpj: formatarCNPJNoSheets(linha[2]?.toString().trim() || ''),
      fornecedor: linha[3]?.toString().trim() || '',
      ultima_etapa: ultimaEtapaFormatada, // üî• MUDOU: ultima_etapa em vez de ultimo_evento
      etapa: linha[5]?.toString().trim() || '', // üî• MUDOU: etapa em vez de evento
      observacoes: linha[6]?.toString().trim() || '',
      contrato_enviado: linha[7]?.toString().trim() || '',
      contrato_assinado: linha[8]?.toString().trim() || '',
      ativacao: ativacaoFormatada,
      link: linha[10]?.toString().trim() || '',
      mensalidade: typeof linha[11] === 'number' ? linha[11] : 0,
      mensalidade_sim: typeof linha[12] === 'number' ? linha[12] : 0,
      tarifa: linha[13]?.toString().trim() || '',
      percentual_tarifa: percentualTarifa,
      adesao: adesaoFormatada,
      situacao: (linha[16]?.toString().trim() || 'Novo registro'),
      waitlabel: waitlabel
    };

    console.log("‚úÖ [DOKTORBANK] Cadastro processado:", {
      id: resultado.id,
      razao_social: resultado.razao_social,
      ultima_etapa: resultado.ultima_etapa, // üî• MUDOU
      etapa: resultado.etapa, // üî• MUDOU
      ativacao: resultado.ativacao
    });
    
    return resultado;
    
  } catch (error) {
    console.error("‚ùå [DOKTORBANK] Erro em buscarCadastroPorIDComWaitlabel:", error);
    return { encontrado: false, mensagem: "Erro: " + error.message };
  }
}

// üî•üî•üî• FUN√á√ÉO PARA OBTER FILTROS - ATUALIZADA COM AS NOVAS ETAPAS
function obterFiltrosDisponiveis() {
  try {
    const waitlabelAtual = CONFIG_FILHA.WAITLABEL_FILHA;
    const cadastros = buscarTodosCadastrosComWaitlabel(waitlabelAtual);
    
    // üî•üî•üî• ETAPAS V√ÅLIDAS ATUALIZADAS (SEM CL√çNICA E WL, COM RETORNO EXTERNO)
    const etapasValidas = [
      "PENDENTE FORNECEDOR(ES)",
      "PENDENTE SIM", 
      "PENDENTE RETORNO EXTERNO"
    ];
    
    const situacoesValidas = [
      "NOVO REGISTRO",
      "EM ANDAMENTO", 
      "DESISTIU",
      "REJEITADO",
      "CADASTRADO",
      "DESCREDENCIADO"
    ];
    
    // Coletar dados √∫nicos dos cadastros
    const etapasEncontradas = new Set();
    const situacoesEncontradas = new Set();
    const fornecedoresEncontrados = new Set();
    
    cadastros.forEach(cadastro => {
      if (cadastro.etapa && cadastro.etapa.trim() !== '') {
        // üî• FILTRAR APENAS ETAPAS V√ÅLIDAS
        const etapaNormalizada = normalizarTexto(cadastro.etapa);
        if (etapasValidas.includes(etapaNormalizada)) {
          etapasEncontradas.add(cadastro.etapa);
        }
      }
      
      if (cadastro.situacao && cadastro.situacao.trim() !== '') {
        situacoesEncontradas.add(cadastro.situacao);
      }
      
      if (cadastro.fornecedor && cadastro.fornecedor.trim() !== '') {
        fornecedoresEncontrados.add(cadastro.fornecedor);
      }
    });
    
    // Ordenar os resultados
    const etapasOrdenadas = Array.from(etapasEncontradas).sort();
    const situacoesOrdenadas = Array.from(situacoesEncontradas).sort();
    const fornecedoresOrdenados = Array.from(fornecedoresEncontrados).sort();
    
    console.log("üéØ [DOKTORBANK] Filtros dispon√≠veis - Etapas:", etapasOrdenadas);
    console.log("üéØ [DOKTORBANK] Filtros dispon√≠veis - Situa√ß√µes:", situacoesOrdenadas);
    console.log("üéØ [DOKTORBANK] Filtros dispon√≠veis - Fornecedores:", fornecedoresOrdenados.length);
    
    return {
      etapas: etapasOrdenadas,
      situacoes: situacoesOrdenadas,
      fornecedores: fornecedoresOrdenados,
      // üî• ADICIONAR LISTA DE ETAPAS V√ÅLIDAS PARA VALIDA√á√ÉO
      etapasValidas: etapasValidas,
      situacoesValidas: situacoesValidas
    };
    
  } catch (error) {
    console.error("‚ùå [DOKTORBANK] Erro em obterFiltrosDisponiveis:", error);
    return {
      etapas: [],
      situacoes: [],
      fornecedores: [],
      etapasValidas: [],
      situacoesValidas: []
    };
  }
}

// üî•üî•üî• FUN√á√ÉO DE VALIDA√á√ÉO DE ETAPA - ATUALIZADA
function validarEtapaVisualizacao(etapa, situacao) {
  // üî• VALIDAR APENAS PARA "EM ANDAMENTO" E "NOVO REGISTRO"
  const situacaoNormalizada = normalizarTexto(situacao || '');
  const precisaValidarEtapa = situacaoNormalizada === 'EM ANDAMENTO' || situacaoNormalizada === 'NOVO REGISTRO';
  
  if (!precisaValidarEtapa) {
    console.log("‚úÖ [DOKTORBANK] Situa√ß√£o n√£o requer valida√ß√£o de etapa");
    return { valida: true, etapa: etapa ? normalizarTexto(etapa) : '' };
  }
  
  // üî• SE √â "EM ANDAMENTO" OU "NOVO REGISTRO", ENT√ÉO ETAPA √â OBRIGAT√ìRIA
  if (!etapa || etapa.trim() === '') {
    return { 
      valida: false, 
      mensagem: `‚ùå Para situa√ß√µes "${situacao}" o campo Etapa √© obrigat√≥rio!` 
    };
  }
  
  // üî• NOVAS ETAPAS V√ÅLIDAS (SEM CL√çNICA E WL, COM RETORNO EXTERNO)
  const etapasValidas = [
    "PENDENTE FORNECEDOR(ES)",
    "PENDENTE SIM", 
    "PENDENTE RETORNO EXTERNO"
  ];
  
  const etapaNormalizada = normalizarTexto(etapa);
  
  // üî• BLOQUEAR EXPLICITAMENTE "DESISTIU" E OUTRAS ETAPAS INV√ÅLIDAS
  const etapasBloqueadas = ["DESISTIU", "REJEITADO", "CADASTRADO", "NOVO REGISTRO", "EM ANDAMENTO", "DESCREDENCIADO"];
  
  if (etapasBloqueadas.includes(etapaNormalizada)) {
    const mensagemErro = `‚ùå ETAPA N√ÉO PERMITIDA!\n\nA etapa "${etapa}" √© uma SITUA√á√ÉO, n√£o uma etapa do processo.\n\nüìã ETAPAS V√ÅLIDAS (do processo):\n‚Ä¢ PENDENTE FORNECEDOR(ES)\n‚Ä¢ PENDENTE SIM\n‚Ä¢ PENDENTE RETORNO EXTERNO\n\nüí° Use o campo "Situa√ß√£o" para: ${etapa}`;
    
    return { valida: false, mensagem: mensagemErro };
  }
  
  if (!etapasValidas.includes(etapaNormalizada)) {
    const mensagemErro = `‚ùå ETAPA INV√ÅLIDA!\n\nA etapa "${etapa}" n√£o √© v√°lida.\n\nüìã ETAPAS V√ÅLIDAS:\n‚Ä¢ PENDENTE FORNECEDOR(ES)\n‚Ä¢ PENDENTE SIM\n‚Ä¢ PENDENTE RETORNO EXTERNO\n\nSelecione uma das etapas acima para continuar.`;
    
    return { valida: false, mensagem: mensagemErro };
  }
  
  return { valida: true, etapa: etapaNormalizada };
}

// üî•üî•üî• FUN√á√ÉO DE TESTE ATUALIZADA PARA ETAPAS
function testarDatasVisualizacao() {
  try {
    console.log("=== üß™ [DOKTORBANK] TESTE ESPEC√çFICO PARA VISUALIZA√á√ÉO ===");
    
    const ss = SpreadsheetApp.openById(CONFIG_FILHA.ID_PLANILHA_MAE);
    const aba = ss.getSheetByName(CONFIG_FILHA.WAITLABEL_FILHA);
    
    if (!aba) {
      return { error: "Aba n√£o encontrada" };
    }
    
    // Buscar algumas linhas para testar
    const dadosTeste = aba.getRange(2, 1, 5, 17).getValues();
    const resultadosTeste = [];
    
    for (let i = 0; i < dadosTeste.length; i++) {
      const linha = dadosTeste[i];
      if (!linha[0] || linha[0].toString().trim() === '') continue;
      
      const ultimaEtapaOriginal = linha[4]; // üî• MUDOU: ultima_etapa
      const etapaAtual = linha[5]; // üî• NOVO: etapa atual
      const ativacaoOriginal = linha[9];
      
      // Processar como na fun√ß√£o corrigida COM FUSO HOR√ÅRIO
      let ultimaEtapaFormatada = ultimaEtapaOriginal ? ultimaEtapaOriginal.toString() : '';
      if (ultimaEtapaOriginal instanceof Date) {
        // üî• CORRE√á√ÉO DO FUSO: Subtrair 5 horas para UTC ‚Üí Bras√≠lia
        const dataUTC = ultimaEtapaOriginal;
        const dataBrasilia = new Date(dataUTC.getTime() - (5 * 60 * 60 * 1000));
        ultimaEtapaFormatada = Utilities.formatDate(dataBrasilia, CONFIG_FILHA.TIMEZONE, "dd/MM/yyyy HH:mm:ss");
      }
      
      let ativacaoFormatada = '';
      if (ativacaoOriginal) {
        if (ativacaoOriginal instanceof Date) {
          ativacaoFormatada = Utilities.formatDate(ativacaoOriginal, CONFIG_FILHA.TIMEZONE, "yyyy-MM-dd");
        } else {
          ativacaoFormatada = ativacaoOriginal.toString();
        }
      }
      
      resultadosTeste.push({
        linha: i + 2,
        razao_social: linha[0]?.toString().trim() || '',
        etapa_atual: etapaAtual?.toString().trim() || '', // üî• NOVO: mostrar etapa atual
        ultima_etapa_original: ultimaEtapaOriginal, // üî• MUDOU
        ultima_etapa_formatada: ultimaEtapaFormatada, // üî• MUDOU
        ativacao_original: ativacaoOriginal,
        ativacao_formatada: ativacaoFormatada
      });
    }
    
    console.log("üìÖ [DOKTORBANK] Resultados do teste de visualiza√ß√£o:", resultadosTeste);
    
    return {
      success: true,
      teste_visualizacao: resultadosTeste,
      message: "Teste de visualiza√ß√£o Doktorbank conclu√≠do"
    };
    
  } catch (error) {
    console.error("‚ùå [DOKTORBANK] Erro no teste de visualiza√ß√£o:", error);
    return { error: error.message };
  }
}

// üî•üî•üî• FUN√á√ïES AUXILIARES (MANTIDAS E ATUALIZADAS)
function formatarCNPJNoSheets(cnpj) {
  if (!cnpj) return '';
  if (cnpj.toString().includes('.') || cnpj.toString().includes('/') || cnpj.toString().includes('-')) {
    return cnpj.toString();
  }
  const cnpjStr = cnpj.toString().replace(/\D/g, '');
  if (cnpjStr.length === 14) {
    return cnpjStr.replace(/^(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
  }
  return cnpj;
}

// üî•üî•üî• FUN√á√ÉO DE NORMALIZA√á√ÉO DE TEXTO
function normalizarTexto(texto) {
  if (!texto || typeof texto !== 'string') return texto;
  return texto
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .toUpperCase()
    .trim();
}

// üî•üî•üî• FUN√á√ÉO DE TESTE ATUALIZADA
function testar() {
  const totalCadastros = buscarTodosCadastrosComWaitlabel(CONFIG_FILHA.WAITLABEL_FILHA).length;
  const testeDatas = testarDatasVisualizacao();
  const filtros = obterFiltrosDisponiveis();
  
  return { 
    success: true, 
    message: "‚úÖ Sistema DOKTORBANK funcionando!",
    modo: "Somente leitura - CORRIGIDO PARA ETAPAS E FUSO HOR√ÅRIO",
    waitlabel: CONFIG_FILHA.WAITLABEL_FILHA,
    totalCadastros: totalCadastros,
    etapas_validas: filtros.etapasValidas, // üî• NOVO: mostrar etapas v√°lidas
    situacoes_validas: filtros.situacoesValidas, // üî• NOVO: mostrar situa√ß√µes v√°lidas
    teste_datas: testeDatas,
    timestamp: new Date().toISOString()
  };
}

// üî•üî•üî• FUN√á√ÉO PARA BUSCAR POR CNPJ - ADICIONADA PARA COMPLETAR
function buscarTodosCadastrosPorCNPJComWaitlabel(cnpj, waitlabel) {
  try {
    const cadastros = buscarTodosCadastrosComWaitlabel(waitlabel);
    const cnpjBuscado = cnpj.toString().replace(/\D/g, '');
    const cadastrosEncontrados = [];
    
    for (const cadastro of cadastros) {
      const cnpjCadastro = cadastro.cnpj?.toString().replace(/\D/g, '') || '';
      if (cnpjCadastro === cnpjBuscado) {
        cadastrosEncontrados.push(cadastro);
      }
    }
    
    return cadastrosEncontrados;
    
  } catch (error) {
    console.error("‚ùå [DOKTORBANK] Erro em buscarTodosCadastrosPorCNPJComWaitlabel:", error);
    return [];
  }
}
